/*******************************************************************************
 * This file is part of the Twig eclipse plugin.
 * 
 * (c) Robert Gruendler <r.gruendler@gmail.com>
 * 
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 ******************************************************************************/
package com.dubture.twig.core.documentModel.parser;

import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.swing.text.Segment;

import org.eclipse.core.resources.IProject;
import org.eclipse.php.internal.core.documentModel.parser.Scanner;
import org.eclipse.php.internal.core.documentModel.parser.StateStack;
import org.eclipse.php.internal.core.documentModel.parser.regions.PHPRegionTypes;
import org.eclipse.php.internal.core.documentModel.partitioner.PHPPartitionTypes;
import org.eclipse.php.internal.core.preferences.TaskPatternsProvider;
import org.eclipse.php.internal.core.util.collections.IntHashtable;
import org.eclipse.wst.sse.core.internal.parser.ContextRegion;
import org.eclipse.wst.sse.core.internal.provisional.text.ITextRegion;

import com.dubture.twig.core.documentModel.parser.regions.TwigRegionTypes;

/**
 * 
 * see {@link AbstractTwigLexer} 34 php.core :
 * /Resources/parserTools/parser/php53 ast_scanner.flex
 * 
 * 
 * @author "Robert Gruendler <r.gruendler@gmail.com>"
 * 
 */
@SuppressWarnings("restriction")
public abstract class AbstractTwigLexer implements Scanner, TwigRegionTypes
{
    protected TwigTokenizer tokenizer = null;
    
    public void setTokenizer(TwigTokenizer tokenizer) {
        this.tokenizer = tokenizer;        
    }
    
    // should be auto-generated by jflex
    protected abstract int getZZEndRead();

    protected abstract int getZZLexicalState();

    protected abstract int getZZMarkedPos();

    protected abstract int getZZPushBackPosition();

    protected abstract int getZZStartRead();

    protected abstract void pushBack(int i);

    public abstract char[] getZZBuffer();

    public abstract void yybegin(int newState);

    public abstract int yylength();

    public abstract String yytext();

    public abstract void reset(Reader reader, char[] buffer, int[] parameters);

    public abstract int yystate();

    public abstract int[] getParamenters();

    /**
     * This character denotes the end of file
     */
    final public static int YYEOF = -1;

    protected static final boolean isLowerCase(final String text)
    {
        if (text == null)
            return false;
        for (int i = 0; i < text.length(); i++)
            if (!Character.isLowerCase(text.charAt(i)))
                return false;
        return true;
    }



    protected int defaultReturnValue = -1;

    protected int firstPos = -1; // the first position in the array

    protected StateStack twigStack;

    /**
     * build a key that represents the current state of the lexer.
     */
    private int buildStateKey()
    {
        int rv = getZZLexicalState();

        for (int i = 0; i < twigStack.size(); i++)
            rv = 31 * rv + twigStack.get(i);
        return rv;
    }

    public Object createLexicalStateMemento()
    {
        // buffered token state
        if (bufferedTokens != null && !bufferedTokens.isEmpty()) {
            return bufferedState;
        }

        final int key = buildStateKey();
        Object state = getLexerStates().get(key);
        if (state == null) {
            state = new BasicLexerState(this);
            getLexerStates().put(key, state);
        }
        return state;
    }

    // A pool of states. To avoid creation of a new state on each createMemento.
    protected abstract IntHashtable getLexerStates();


    // lex to the EOF. and return the ending state.
    public Object getEndingState() throws IOException
    {
        lexToEnd();
        return createLexicalStateMemento();
    }

    /**
     * return the index where start we started to lex.
     */
    public int getFirstIndex()
    {
        return firstPos;
    }

    public int getMarkedPos()
    {
        return getZZMarkedPos();
    }

    public void getText(final int start, final int length, final Segment s)
    {
        if (start + length > getZZEndRead())
            throw new RuntimeException("bad segment !!"); //$NON-NLS-1$
        s.array = getZZBuffer();
        s.offset = start;
        s.count = length;
    }

    public int getTokenStart()
    {
        return getZZStartRead() - getZZPushBackPosition();
    }

    public void initialize(final int state)
    {
        twigStack = new StateStack();
        yybegin(state);
    }

    /**
     * reset to a new segment. this do not change the state of the lexer. This
     * method is used to scan nore than one segment as if the are one segment.
     */

    // lex to the end of the stream.
    public String lexToEnd() throws IOException
    {
        String curr = yylex();
        String last = curr;
        while (curr != null) {
            last = curr;
            curr = yylex();
        }
        return last;
    }

    public String lexToTokenAt(final int offset) throws IOException
    {
        if (firstPos + offset < getZZMarkedPos())
            throw new RuntimeException("Bad offset"); //$NON-NLS-1$
        String t = yylex();
        while (getZZMarkedPos() < firstPos + offset && t != null)
            t = yylex();
        return t;
    }

    protected void popState()
    {
        yybegin(twigStack.popStack());
    }

    protected void pushState(final int state)
    {
        twigStack.pushStack(getZZLexicalState());
        yybegin(state);
    }

    public void setState(final Object state)
    {
        ((LexerState) state).restoreState(this);
    }

    public int yystart()
    {
        return getZZStartRead();
    }

    public LinkedList<ITextRegion> bufferedTokens = null;
    public int bufferedLength;
    public Object bufferedState;

    /**
     * @return the next token from the php lexer
     * @throws IOException
     */
    public String getNextToken() throws IOException
    {
        if (bufferedTokens != null) {
            if (bufferedTokens.isEmpty()) {
                bufferedTokens = null;
            } else {
                return removeFromBuffer();
            }
        }

        bufferedState = createLexicalStateMemento();
        String yylex = yylex();
        if (yylex == PHPRegionTypes.PHPDOC_COMMENT) {
            final StringBuffer buffer = new StringBuffer();
            int length = 0;
            while (yylex == PHPRegionTypes.PHPDOC_COMMENT) {
                buffer.append(yytext());
                yylex = yylex();
                length++;
            }
            bufferedTokens = new LinkedList<ITextRegion>();
            checkForTodo(bufferedTokens, PHPRegionTypes.PHPDOC_COMMENT, 0,
                    length, buffer.toString());
            bufferedTokens.add(new ContextRegion(yylex, 0, yylength(),
                    yylength()));
            yylex = removeFromBuffer();
        } else if (PHPPartitionTypes.isPHPCommentState(yylex)) {
            bufferedTokens = new LinkedList<ITextRegion>();
            checkForTodo(bufferedTokens, yylex, 0, yylength(), yytext());
            yylex = removeFromBuffer();
        }

        if (yylex == TWIG_CLOSETAG || yylex == TWIG_STMT_CLOSE
                || yylex == TWIG_COMMENT_CLOSE) {
            pushBack(getLength());
        }

        return yylex;
    }

    /**
     * @return the last token from buffer
     */
    private String removeFromBuffer()
    {
        ITextRegion region = (ITextRegion) bufferedTokens.removeFirst();
        bufferedLength = region.getLength();
        return region.getType();
    }

    public int getLength()
    {
        return bufferedTokens == null ? yylength() : bufferedLength;
    }

    private Pattern[] todos;

    public void setPatterns(IProject project)
    {
        if (project != null) {
            todos = TaskPatternsProvider.getInstance().getPatternsForProject(
                    project);
        } else {
            todos = TaskPatternsProvider.getInstance()
                    .getPetternsForWorkspace();
        }
    }

    /**
     * @param bufferedTokens2
     * @param token
     * @param commentStart
     * @param commentLength
     * @param comment
     * @return a list of todo ITextRegion
     */
    private void checkForTodo(List<ITextRegion> result, String token,
            int commentStart, int commentLength, String comment)
    {
        ArrayList<Matcher> matchers = createMatcherList(comment);
        int startPosition = 0;

        Matcher matcher = getMinimalMatcher(matchers, startPosition);
        ITextRegion tRegion = null;
        while (matcher != null) {
            int startIndex = matcher.start();
            int endIndex = matcher.end();
            if (startIndex != startPosition) {
                tRegion = new ContextRegion(token,
                        commentStart + startPosition, startIndex
                                - startPosition, startIndex - startPosition);
                result.add(tRegion);
            }
            tRegion = new ContextRegion(PHPRegionTypes.PHPDOC_TODO,
                    commentStart + startIndex, endIndex - startIndex, endIndex
                            - startIndex);
            result.add(tRegion);
            startPosition = endIndex;
            matcher = getMinimalMatcher(matchers, startPosition);
        }
        final int length = commentLength - startPosition;
        if (length != 0) {
            result.add(new ContextRegion(token, commentStart + startPosition,
                    length, length));
        }
    }

    private ArrayList<Matcher> createMatcherList(String content)
    {
        ArrayList<Matcher> list = new ArrayList<Matcher>(todos.length);
        for (int i = 0; i < todos.length; i++) {
            list.add(i, todos[i].matcher(content));
        }
        return list;
    }

    private Matcher getMinimalMatcher(ArrayList<Matcher> matchers,
            int startPosition)
    {
        Matcher minimal = null;
        int size = matchers.size();
        for (int i = 0; i < size;) {
            Matcher tmp = (Matcher) matchers.get(i);
            if (tmp.find(startPosition)) {
                if (minimal == null || tmp.start() < minimal.start()) {
                    minimal = tmp;
                }
                i++;
            } else {
                matchers.remove(i);
                size--;
            }
        }
        return minimal;
    }

    private static class BasicLexerState implements LexerState
    {

        private final byte lexicalState;
        private StateStack twigStack;

        public BasicLexerState(AbstractTwigLexer lexer)
        {
            if (!lexer.twigStack.isEmpty()) {
                twigStack = lexer.twigStack.createClone();
            }
            lexicalState = (byte) lexer.getZZLexicalState();
        }

        @Override
        public boolean equals(final Object o)
        {
            if (o == this)
                return true;
            if (o == null)
                return false;
            if (!(o instanceof BasicLexerState))
                return false;
            final BasicLexerState tmp = (BasicLexerState) o;
            if (tmp.lexicalState != lexicalState)
                return false;
            if (twigStack != null && !twigStack.equals(tmp.twigStack))
                return false;
            return twigStack == tmp.twigStack;
        }

        public boolean equalsCurrentStack(final LexerState obj)
        {
            if (obj == this)
                return true;
            if (obj == null)
                return false;
            if (!(obj instanceof BasicLexerState))
                return false;
            final BasicLexerState tmp = (BasicLexerState) obj;
            if (tmp.lexicalState != lexicalState)
                return false;
            final StateStack activeStack = getActiveStack();
            final StateStack otherActiveStack = tmp.getActiveStack();
            if (!(activeStack == otherActiveStack || activeStack != null
                    && activeStack.equals(otherActiveStack)))
                return false;
            return true;
        }

        public boolean equalsTop(final LexerState obj)
        {
            return obj != null && obj.getTopState() == lexicalState;
        }

        protected StateStack getActiveStack()
        {
            return twigStack;
        }

        public int getTopState()
        {
            return lexicalState;
        }

        public boolean isSubstateOf(final int state)
        {
            if (lexicalState == state)
                return true;
            final StateStack activeStack = getActiveStack();
            if (activeStack == null)
                return false;
            return activeStack.contains(state);
        }

        public void restoreState(final Scanner scanner)
        {
            final AbstractTwigLexer lexer = (AbstractTwigLexer) scanner;

            if (twigStack == null)
                lexer.twigStack.clear();
            else
                lexer.twigStack.copyFrom(twigStack);

            lexer.yybegin(lexicalState);
        }

        @Override
        public String toString()
        {
            final StateStack stack = getActiveStack();
            final String stackStr = stack == null ? "null" : stack.toString(); //$NON-NLS-1$
            return "Stack: " + stackStr + ", currState: " + lexicalState; //$NON-NLS-1$ //$NON-NLS-2$
        }

    }

    protected void reportError()
    {

    }
}
